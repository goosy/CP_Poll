TYPE "MB_S"
    STRUCT
        Address : BYTE;    //子站地址，当地址为0时代表不轮询。
        MFunction : BYTE;    //modbus 功能号
        StartAddress : WORD;    //起始地址
        Number : WORD;    //长度
        CRC : WORD;    //CRC
        recvDB : INT;    //接收DB块号
        recvDBB : INT;    //接收DB起始地址
    END_STRUCT
END_TYPE

FUNCTION_BLOCK "MB_Poll"

    VAR_INPUT 
        customTrigger : BOOL; //默认为false,即顺序轮询。当本参数为true时，由参数R定义轮询方式。
        R : BOOL; // 当customTrigger置位时起作用，在R的上升沿发出当次轮询。比如可以把一个秒脉冲赋值给R
        Laddr : INT; // 模块地址
        Poll_DB : INT; // 轮询DB号
        overTime : TIME := T#2S;   // 单次询问的最大等待时间 
    END_VAR

    VAR
        trigger : BOOL; // 内部控制CP341发送
        roundWorking : BOOL; // 当前轮询进行中
        Poll : MB_S;
        Index : INT ; // 第几轮
        sendDBB : INT;    
        recvDB : INT;    
        recvDBB : INT;   
        CP_SND_IDB : P_SND_RK;
        CP_RCV_IDB : P_RCV_RK;
        TimeOver : TON;
    END_VAR

    VAR_TEMP
        DB_NO : WORD;
    END_VAR


BEGIN
    // 范围检查
    IF Index < 0 OR Index > 31 THEN
        Index := 0;
    END_IF;
    
    // 发送参数
    DB_NO := INT_TO_WORD(Poll_DB);
    sendDBB := Index * 12;
    // 忽略子站地址为0的轮询
    WHILE Index >= 0 AND Index < 32 AND WORD_TO_BLOCK_DB(DB_NO).DB[sendDBB] = B#16#0 DO
        Index := Index + 1;
    END_WHILE;
    IF Index = 32 THEN
        RETURN;
    END_IF;
    
    // 接收参数
    recvDB := WORD_TO_INT(WORD_TO_BLOCK_DB(DB_NO).DW[Index*12+8]);
    recvDBB := WORD_TO_INT(WORD_TO_BLOCK_DB(DB_NO).DW[Index*12+10]);
    
    // to-do: 写入CRC16

    // 发送数据
    CP_SND_IDB (
           SF                       := 'S',
           REQ                      := trigger,
           LADDR                    := Laddr,
           DB_NO                    := Poll_DB,
           DBB_NO                   := sendDBB,
           LEN                      := 8,
           R_TYP                    := 'X');
    IF CP_SND_IDB.DONE OR CP_SND_IDB.ERROR THEN
        trigger := FALSE; //取消触发
    END_IF;

    //接收功能
    CP_RCV_IDB (
           EN_R                     := TRUE,
           LADDR                    := Laddr,
           DB_NO                    := recvDB,
           DBB_NO                   := recvDBB);
    //CP_RCV_IDB.NDR

    // 启动超时
    TimeOver(
           IN := roundWorking,
           PT := overTime);

    // 处理 roundWorking
    IF customTrigger THEN
        IF NOT R THEN 
            // -R
            trigger := FALSE;
            roundWorking := FALSE;
        ELSIF NOT roundWorking THEN 
            // R & -roundWorking
            // 在 R 上升沿启动新一轮计数增加
            Index := Index + 1;
            roundWorking := TRUE;
            trigger := TRUE;
        END_IF;
    ELSE
        IF CP_RCV_IDB.NDR OR TimeOver.Q THEN
            // 当前询问结束，计数增加
            Index := Index + 1; 
            roundWorking := FALSE; 
            trigger := FALSE;
        ELSIF NOT roundWorking THEN
            // 启动新一轮
            roundWorking := TRUE;
            trigger := TRUE;
        END_IF;
    END_IF;

    // 接收成功时处理
    IF CP_RCV_IDB.NDR THEN
        OnRecv(
            RecvDB := recvDB,
            RecvDBB := recvDBB,
            LEN := 0);
    END_IF;

END_FUNCTION_BLOCK

