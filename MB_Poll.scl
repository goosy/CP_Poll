FUNCTION_BLOCK "MB_Poll"

    VAR_INPUT 
        customTrigger : BOOL ; //默认为false,即顺序轮询。当本参数为true时，由参数R定义轮询方式。
        R : BOOL ; // 当customTrigger置位时起作用，在R的上升沿发出当次轮询。比如可以把一个秒脉冲赋值给R
        Laddr : INT ; // 模块地址
        overTime : TIME := T#2S;   // 单次询问的最大等待时间 
        DATA : ANY ; // 轮询定义系列数据区
        Pointer_S AT DATA : STRUCT  // Define ANY structure
            SyntaxID: BYTE ;  
            DataType: BYTE ;
            DataCount: WORD ;
            DB_Nummer: WORD ;
            Byte_Pointer: DWORD ;
        END_STRUCT ;
    END_VAR

    VAR_IN_OUT
    END_VAR

    VAR
        trigger : BOOL; // 内部控制CP341发送
        transmitting : BOOL; // 当前轮询进行中
        initialized : BOOL ; // 输入已初始化
        Index : INT ; // 第几轮
        baseOffset : INT ;
        transLength : INT ;
        Poll_DB : INT; // 轮询DB号
        sendDBB : INT;    
        recvDB : INT ;    //接收DB块号
        recvDBB : INT ;    //接收DB起始地址
        CP_SND_IDB : P_SND_RK;
        CP_RCV_IDB : P_RCV_RK;
        TimeOver : TON;
    END_VAR


BEGIN

    IF NOT initialized THEN
        IF (Pointer_S.DB_Nummer = 0) 
            OR (Pointer_S.DataType <> B#16#2)
            OR ((Pointer_S.Byte_Pointer AND DW#16#ff000000) <> DW#16#84000000) THEN
            RETURN;    
        END_IF;    
        Poll_DB := WORD_TO_INT(Pointer_S.DB_Nummer);
        baseOffset := DWORD_TO_INT(SHR(IN := Pointer_S.Byte_Pointer, N := 3));
        transLength := WORD_TO_INT(Pointer_S.DataCount)/12;
        initialized := TRUE;
    END_IF;

    // 范围检查
    IF Index < 0 OR Index >= transLength THEN
        Index := 0;
    END_IF;
    
    // 发送参数
    sendDBB := Index * 12 + baseOffset;
    // 接收参数
    recvDB := WORD_TO_INT(WORD_TO_BLOCK_DB(Pointer_S.DB_Nummer).DW[sendDBB+8]);
    recvDBB := WORD_TO_INT(WORD_TO_BLOCK_DB(Pointer_S.DB_Nummer).DW[sendDBB+10]);
    
    // to-do: 写入CRC16

    // 发送数据
    CP_SND_IDB (
        SF                       := 'S',
        REQ                      := trigger,
        LADDR                    := Laddr,
        DB_NO                    := Poll_DB,
        DBB_NO                   := sendDBB,
        LEN                      := 8,
        R_TYP                    := 'X');
    IF CP_SND_IDB.DONE OR CP_SND_IDB.ERROR THEN
        trigger := FALSE; //取消触发
    END_IF;

    //接收功能
    CP_RCV_IDB (
        EN_R                     := TRUE,
        LADDR                    := Laddr,
        DB_NO                    := recvDB,
        DBB_NO                   := recvDBB);

    // 启动超时
    TimeOver(
           IN := transmitting,
           PT := overTime);

    // 处理 transmitting
    IF customTrigger THEN
        IF NOT R THEN 
            // -R
            trigger := FALSE;
            transmitting := FALSE;
        ELSIF NOT transmitting THEN 
            // R & -transmitting
            // 在 R 上升沿启动新一轮计数增加
            Index := Index + 1;
            transmitting := TRUE;
            trigger := TRUE;
        END_IF;
    ELSE
        IF CP_RCV_IDB.NDR OR TimeOver.Q THEN
            // 当前询问结束，计数增加
            Index := Index + 1; 
            transmitting := FALSE; 
            trigger := FALSE;
        ELSIF NOT transmitting THEN
            // 启动新一轮
            transmitting := TRUE;
            trigger := TRUE;
        END_IF;
    END_IF;

    // 接收成功时处理
    IF CP_RCV_IDB.NDR THEN
        OnRecv(
            RecvDB := recvDB,
            RecvDBB := recvDBB,
            LEN := 0);
    END_IF;

END_FUNCTION_BLOCK

