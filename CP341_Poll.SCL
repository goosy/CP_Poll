FUNCTION_BLOCK "CP341_Poll"
TITLE='485轮询'
VERSION:'0.1'
KNOW_HOW_PROTECT
AUTHOR:Goosy
NAME:SC
FAMILY:GoosyLib

VAR_INPUT 
    customTrigger : BOOL ; //默认为false,即顺序轮询。当本参数为true时，由参数R定义轮询方式。
    REQ : BOOL ; // 当customTrigger置位时起作用，在REQ的上升沿发出当次轮询。比如可以把一个秒脉冲赋值给R
    Laddr : INT ; // 模块地址
    timeout : TIME := T#2S;   // 单次询问的最大等待时间 
    overTimes : INT := 3; // 单次询问的回应时间大于一个轮询周期的 overTimes 倍，判定超时，标记该设备数据无效
    DATA : ANY ; // 轮询定义系列数据区
    Pointer_S AT DATA : STRUCT  // Define ANY structure
        SyntaxID: BYTE ;  
        DataType: BYTE ;
        DataCount: INT ;
        DB_Nummer: WORD ;
        Byte_Pointer: DWORD ;
    END_STRUCT ;
END_VAR

VAR_OUTPUT
    OnReceive : BOOL; // 已接收指示
    receiveDB : INT; // 已接收DB号
    receiveDBB : INT; // 已接收DB偏移量
    receiveLEN : INT; // 已接收数据的长度
END_VAR

VAR
    trigger : BOOL; // 内部控制CP341发送
    transmitting : BOOL; // 当前轮询进行中
    initialized : BOOL ; // 输入已初始化
    baseOffset : INT ;
    transLength : INT ;
    index : INT ; // 第几轮
    Poll_DB : INT; // 轮询DB号
    CP_SEND : P_SND_RK;
    CP_RCV : P_RCV_RK;
    TimeOver : TON;
    pollList : ARRAY [0..31] OF //轮询定义
    STRUCT
        sendDBB : INT ;
        length : INT ;
        recvDB : INT ;
        recvDBB : INT ;
        waitCount : INT ;
    END_STRUCT ;
END_VAR

VAR_TEMP
    w_PollDB : WORD ;
    recvDB : INT ;
    recvDBB : INT ;
    currOffset : INT ; // 当前轮询的偏移
    next : INT ;
END_VAR


BEGIN

    // 初始化轮询列表
    IF NOT initialized THEN
        IF (Pointer_S.DB_Nummer = 0) 
            OR (Pointer_S.DataType <> B#16#2)
            OR ((Pointer_S.Byte_Pointer AND DW#16#ff000000) <> DW#16#84000000) THEN
            RETURN;    
        END_IF;
        w_PollDB := Pointer_S.DB_Nummer;
        Poll_DB := WORD_TO_INT(w_PollDB);
        baseOffset := DWORD_TO_INT(SHR(IN := Pointer_S.Byte_Pointer, N := 3));
        index := 0;
        currOffset := baseOffset;
        REPEAT
            // current
            pollList[index].sendDBB := currOffset + 8;
            next := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset]);
            pollList[index].length := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset + 2]);
            pollList[index].recvDB := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset + 4]);
            pollList[index].recvDBB := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset + 6]);
            pollList[index].waitCount := 0;

            // next
            currOffset := currOffset + next; 
            // 范围检查
            IF next <= 8 OR currOffset >= baseOffset + Pointer_S.DataCount - 8 THEN
                currOffset := baseOffset;
                transLength := index + 1;
            ELSE
                index := index + 1;
            END_IF;
        UNTIL currOffset = baseOffset
        END_REPEAT;
        index := 0;
        initialized := TRUE;
    END_IF;

    IF index >= transLength THEN
        index := 0;
    END_IF;
    recvDB := pollList[index].recvDB;
    recvDBB := pollList[index].recvDBB;
    
    // 发送数据
    CP_SEND (
        SF                       := 'S',
        REQ                      := trigger,
        LADDR                    := Laddr,
        DB_NO                    := Poll_DB,
        DBB_NO                   := pollList[index].sendDBB,
        LEN                      := pollList[index].length,
        R_TYP                    := 'X');
    IF CP_SEND.DONE OR CP_SEND.ERROR THEN
        trigger := FALSE; //取消触发
    END_IF;

    //接收功能
    CP_RCV (
        EN_R                     := TRUE,
        LADDR                    := Laddr,
        DB_NO                    := recvDB,
        DBB_NO                   := recvDBB + 1);

    // 接收成功时处理
    OnReceive := CP_RCV.NDR;
    IF CP_RCV.NDR THEN
        pollList[index].waitCount := 0;
        WORD_TO_BLOCK_DB(INT_TO_WORD(recvDB)).DX[recvDBB,0] := TRUE; // 设置设备正常标志
        receiveDB := recvDB;
        receiveDBB := recvDBB;
        receiveLEN := CP_RCV.LEN;
    END_IF;
    IF pollList[index].waitCount > overTimes THEN // 超时处理
        WORD_TO_BLOCK_DB(INT_TO_WORD(recvDB)).DX[recvDBB, 0] := FALSE;// 设备不正常
    END_IF;    

    // 启动超时
    TimeOver(
           IN := transmitting,
           PT := timeout);
    // 处理 transmitting
    IF customTrigger THEN
        IF NOT REQ THEN 
            // -REQ
            trigger := FALSE;
            transmitting := FALSE;
        ELSIF NOT transmitting THEN 
            // REQ & -transmitting
            // 在 REQ 上升沿启动新一轮计数增加
            pollList[index].waitCount := pollList[index].waitCount + 1;
            index := index + 1;
            transmitting := TRUE;
            trigger := TRUE;
        END_IF;
    ELSE
        IF CP_RCV.NDR OR TimeOver.Q THEN
            // 当前询问结束，计数增加
            IF TimeOver.Q THEN
                pollList[index].waitCount := pollList[index].waitCount + 1;
            END_IF;
            index := index + 1; 
            transmitting := FALSE; 
            trigger := FALSE;
        ELSIF NOT transmitting THEN
            // 启动新一轮
            transmitting := TRUE;
            trigger := TRUE;
        END_IF;
    END_IF;

END_FUNCTION_BLOCK
