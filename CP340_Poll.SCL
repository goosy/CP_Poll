FUNCTION_BLOCK "CP340_Poll"
TITLE='485轮询'
VERSION:'0.1'
KNOW_HOW_PROTECT
AUTHOR:Goosy
NAME:SC
FAMILY:GoosyLib

VAR_INPUT 
    customTrigger : BOOL; //默认为false,即顺序轮询。当本参数为true时，由参数REQ定义轮询方式。
    REQ : BOOL; // 当customTrigger置位时起作用，在REQ的上升沿发出当次轮询。比如可以把一个秒脉冲赋值给REQ
    Laddr : INT; // 模块地址
    timeout : TIME := T#2S;   // 单次询问的最大等待时间 
    overTimes : INT := 3; // 单次询问的回应时间大于一个轮询周期的 overTimes 倍，判定超时，标记该设备数据无效
    DATA : ANY; // 轮询定义系列数据区
    Pointer_S AT DATA : STRUCT  // Define ANY structure
        SyntaxID: BYTE;  
        DataType: BYTE;
        DataCount: INT;
        DB_Nummer: WORD;
        Byte_Pointer: DWORD;
    END_STRUCT;
END_VAR

VAR
    trigger : BOOL; // 内部控制CP341发送
    transmitting : BOOL; // 当前轮询进行中
    initialized : BOOL; // 输入已初始化
    baseOffset : INT; // 轮询区的起始偏移量
    endOffset : INT; // 轮询区的结束偏移量
    transLength : INT;
    index : INT; // 第几轮
    Poll_DB : INT; // 轮询DB号
    CP_SEND : P_SEND;
    CP_RCV : P_RCV;
    TimeOver : TON;
    pollList : ARRAY [0..31] OF STRUCT //轮询定义
        sendDBB : INT;
        length : INT;
        recvDB : INT;
        recvDBB : INT;
        waitCount : INT;
    END_STRUCT;
END_VAR

VAR_TEMP
    w_PollDB : WORD;
    recvDB : INT;
    recvDBB : INT;
    currOffset : INT; // 当前轮询的偏移
    size : INT;    
END_VAR


BEGIN

    // 初始化轮询列表
    IF NOT initialized THEN
        IF (Pointer_S.DB_Nummer = 0) 
            OR (Pointer_S.DataType <> B#16#2)
            OR ((Pointer_S.Byte_Pointer AND DW#16#ff000000) <> DW#16#84000000) THEN
            RETURN;    
        END_IF;
        w_PollDB := Pointer_S.DB_Nummer;
        Poll_DB := WORD_TO_INT(w_PollDB);
        baseOffset := DWORD_TO_INT(SHR(IN := Pointer_S.Byte_Pointer, N := 3));
        index := 0;
        currOffset := baseOffset;
        endOffset := baseOffset + Pointer_S.DataCount;
        REPEAT
            // current
            pollList[index].sendDBB := currOffset + 8;
            size := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset]);
            pollList[index].length := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset + 2]);
            pollList[index].recvDB := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset + 4]);
            pollList[index].recvDBB := WORD_TO_INT(WORD_TO_BLOCK_DB(w_PollDB).DW[currOffset + 6]);
            pollList[index].waitCount := 0;

            // next
            currOffset := currOffset + size; 
            // 范围检查
            IF size <= 8 OR currOffset >= endOffset - 8 THEN
                currOffset := baseOffset;
                transLength := index + 1;
            ELSE
                index := index + 1;
            END_IF;
        UNTIL currOffset = baseOffset
        END_REPEAT;
        index := 0;
        initialized := TRUE;
    END_IF;

    IF index >= transLength THEN
        index := 0;
    END_IF;
    recvDB := pollList[index].recvDB;
    recvDBB := pollList[index].recvDBB;
    
    // 发送数据
    CP_SEND (
        REQ                      := trigger,
        LADDR                    := Laddr,
        DB_NO                    := Poll_DB,
        DBB_NO                   := pollList[index].sendDBB,
        LEN                      := pollList[index].length);
    IF CP_SEND.DONE OR CP_SEND.ERROR THEN
        trigger := FALSE; //取消触发
    END_IF;

    //接收功能
    CP_RCV (
        EN_R                     := TRUE,
        LADDR                    := Laddr,
        DB_NO                    := recvDB,
        DBB_NO                   := recvDBB + 1);

    // 接收成功时处理
    IF CP_RCV.NDR THEN
        pollList[index].waitCount := 0;
        WORD_TO_BLOCK_DB(INT_TO_WORD(recvDB)).DX[recvDBB,0] := TRUE; // 设置设备正常标志
        WORD_TO_BLOCK_DB(INT_TO_WORD(recvDB)).DX[recvDBB,1] := FALSE; // 设置设备无效标志
    END_IF;
    WORD_TO_BLOCK_DB(INT_TO_WORD(recvDB)).DX[recvDBB,2] := CP_RCV.NDR; // 设置设备接收标志
    IF pollList[index].waitCount > overTimes THEN // 超时处理
        WORD_TO_BLOCK_DB(INT_TO_WORD(recvDB)).DX[recvDBB, 0] := FALSE;// 设置设备正常标志
        WORD_TO_BLOCK_DB(INT_TO_WORD(recvDB)).DX[recvDBB, 1] := TRUE;// 设置设备无效标志
    END_IF;    

    // 启动超时
    TimeOver(
           IN := transmitting,
           PT := timeout);
    // 处理 transmitting
    IF customTrigger THEN
        IF NOT REQ THEN 
            // -REQ
            trigger := FALSE;
            transmitting := FALSE;
        ELSIF NOT transmitting THEN 
            // REQ & -transmitting
            // 在 REQ 上升沿启动新一轮计数增加
            pollList[index].waitCount := pollList[index].waitCount + 1;
            index := index + 1;
            transmitting := TRUE;
            trigger := TRUE;
        END_IF;
    ELSE
        IF CP_RCV.NDR OR TimeOver.Q THEN
            // 当前询问结束，计数增加
            IF TimeOver.Q THEN
                pollList[index].waitCount := pollList[index].waitCount + 1;
            END_IF;
            index := index + 1; 
            transmitting := FALSE; 
            trigger := FALSE;
        ELSIF NOT transmitting THEN
            // 启动新一轮
            transmitting := TRUE;
            trigger := TRUE;
        END_IF;
    END_IF;

END_FUNCTION_BLOCK
